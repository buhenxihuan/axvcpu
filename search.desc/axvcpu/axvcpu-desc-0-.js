searchState.loadedDescShard("axvcpu", 0, "This crate provides a simple virtual CPU abstraction for …\nThe width of an access.\nA trait for architecture-specific vcpu.\nThe result of <code>AxArchVCpu::run</code>.\nA virtual CPU with architecture-independent interface.\nThe mutable part of <code>AxVCpu</code>.\nThe vcpu is blocked.\n8-bit access.\nThe configuration for creating a new <code>AxArchVCpu</code>. Used by …\nThe vcpu is created but not initialized yet.\n32-bit access.\nAn external interrupt happened.\nThe vcpu is already initialized and can be bound to a …\nGuest physical address.\nGuest virtual address.\nThe vcpu is halted.\nA physical memory address.\nA virtual memory address.\nAn invalid state.\nThe instruction executed by the vcpu performs a I/O read …\nThe instruction executed by the vcpu performs a I/O write …\nThe instruction executed by the vcpu performs a MMIO read …\nThe instruction executed by the vcpu performs a MMIO write …\nA nested page fault happened. (EPT violation in x86)\nNothing special happened, the vcpu has handled the exit …\n64-bit access.\nThe vcpu is bound to a physical CPU and ready to run.\nThe vcpu is bound to a physical CPU and running.\nThe configuration for setting up a created <code>AxArchVCpu</code>. …\nThe state of a virtual CPU.\n16-bit access.\nAligns the address downwards to the given alignment.\nAligns the address downwards to the given alignment.\nAligns the address downwards to 4096 (bytes).\nAligns the address downwards to 4096 (bytes).\nReturns the offset of the address within the given …\nReturns the offset of the address within the given …\nReturns the offset of the address within a 4K-sized page.\nReturns the offset of the address within a 4K-sized page.\nAligns the address upwards to the given alignment.\nAligns the address upwards to the given alignment.\nAligns the address upwards to 4096 (bytes).\nAligns the address upwards to 4096 (bytes).\nConverts the virtual address to a mutable raw pointer.\nConverts the virtual address to a raw pointer.\nConverts the address to an <code>usize</code>.\nConverts the address to an <code>usize</code>.\nBind the vcpu to the current physical CPU.\nBind the vcpu to the current physical CPU.\nClear the current vcpu on the current physical CPU.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>usize</code> to a physical address.\nReturns the argument unchanged.\nConverts an <code>usize</code> to a virtual address.\nReturns the argument unchanged.\nGet the architecture-specific vcpu.\nGet the current vcpu on the current physical CPU.\nGet a mutable reference to the current vcpu on the current …\nGet the id of the vcpu.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the address has the demanded alignment.\nChecks whether the address has the demanded alignment.\nChecks whether the address is 4K-aligned.\nChecks whether the address is 4K-aligned.\nGet whether the vcpu is the BSP. We always assume the …\nExecute an operation on the architecture-specific vcpu, …\nCreate a new <code>AxArchVCpu</code>.\nCreate a new <code>AxVCpu</code>.\nRun the vcpu until a vm-exit occurs.\nRun the vcpu.\nSet the current vcpu on the current physical CPU.\nSet the entry point of the vcpu.\nSet the EPT root of the vcpu.\nSet the state of the vcpu.\nSetup the vcpu.\nSetup the vcpu.\nGet the state of the vcpu.\nTransition the state of the vcpu. If the current state is …\nUnbind the vcpu from the current physical CPU.\nUnbind the vcpu from the current physical CPU.\nExecute a block with the current vcpu set to <code>&amp;self</code>.\nExecute a block with the state of the vcpu transitioned …\nThe physical address of the MMIO read.\nThe physical address of the MMIO write.\nThe guest physical address of the fault.\nThe data to be written.\nThe data to be written.\nThe port number of the I/O read.\nThe port number of the I/O write.\nThe interrupt vector.\nThe width of the MMIO read.\nThe width of the MMIO write.\nThe width of the I/O read.\nThe width of the I/O write.")